+++
title = "不同场景下C++对象的内存布局"
date = 2022-08-22
[taxnomoies]
tags = ["c++"]
[extra]
mathjax = "tex-mml"
+++

> 本篇文章的内容大部分翻译自[这篇博客](http://www.vishalchovatiya.com/memory-layout-of-cpp-object/)

![](https://secureservercdn.net/160.153.138.178/bkh.972.myftpupload.com/wp-content/uploads/memory-layout-of-C-objects.png)

本文，我们将看到不同c++对象的内存布局，以及不同的存储和访问说明符如何影响内存占用。

## 简单对象

简单是指没有多态(没有虚函数)，同时也没有静态成员的单独类的一个对象。如下所示，

```c++
class X {
    int x;
    float xx;
public:
    X() {}
    ~X() {}

    void printInt() {}
    void printFloat() {}
};
```

其内存布局如下：

```
      |                        |          
      |------------------------| <------ X class object memory layout
      |        int X::x        |
      |------------------------|  stack segment
      |       float X::xx      |       |   
      |------------------------|       |
      |                        |      \|/
      |                        |    
      |                        |
------|------------------------|----------------
      |         X::X()         | 
      |------------------------|       |   
      |        X::~X()         |       |
      |------------------------|      \|/
      |      X::printInt()     |  text segment
      |------------------------|
      |     X::printFloat()    |
      |------------------------|
      |                        |            
```

从上面的例子，我们可以看到只有类的`data members`放在栈上。同时，他们的声明顺序也是一致的。

此外，所有的其他成员函数，构造函数，析构函数，以及[compiler augmented code](http://www.vishalchovatiya.com/inside-the-cpp-object-model/)都是放在文本段中。这些成员函数在调用的时候，会隐式传入一个`this`指针作为其函数的第一个参数。

## 具有虚函数和静态成员的对象

因为引入了虚函数，故会对象中会存在一个虚指针表。

```c++
class X {
    int         x;
    float       xx;
    static int  count;

public:
    X() {}
    virtual ~X() {}

    virtual void printAll() {}
    void printInt() {}
    void printFloat() {}
    static void printCount() {}
};
```
其内存布局如下：

```
      |                        |          
      |------------------------| <------ X class object memory layout
      |        int X::x        |
stack |------------------------|
  |   |       float X::xx      |                      
  |   |------------------------|      |-------|--------------------------|
  |   |         X::_vptr       |------|       |       type_info X        |
 \|/  |------------------------|              |--------------------------|
      |           o            |              |    address of X::~X()    |
      |           o            |              |--------------------------|
      |           o            |              | address of X::printAll() |
      |                        |              |--------------------------|
      |                        |
------|------------------------|------------
      |  static int X::count   |      /|\
      |------------------------|       |
      |           o            |  data segment           
      |           o            |       |
      |                        |      \|/
------|------------------------|------------
      |        X::X()          | 
      |------------------------|       |   
      |        X::~X()         |       |
      |------------------------|       | 
      |      X::printAll()     |      \|/ 
      |------------------------|  text segment
      |      X::printInt()     |
      |------------------------|
      |     X::printFloat()    |
      |------------------------|
      | static X::printCount() |
      |------------------------|
      |                        |
```

我们进行逐一分析，首先非静态成员变量和成员函数依旧不变。

由于引入了新的静态成员变量，在程序的内存布局中出现了一个新的名称，`data segment`。这个部分主要存储一些全局变量，静态变量和常量等。因此，我们的静态成员变量也放在这个部分。这些静态变量并不属于该类的某一个对象拥有，而是这个类所有，可以理解对该类的所有对象是共享的。当我们访问的时候，要考虑到命名空间和作用域名，因此，一般会使用`::`进行访问。此处还涉及到[name mangling](https://www.google.com/url?sa=t&rct=j&q=&esrc=s&source=web&cd=2&cad=rja&uact=8&ved=2ahUKEwjloqrohPToAhXDILcAHU4eC4kQFjABegQIDhAD&url=https%3A%2F%2Fwww.ibm.com%2Fsupport%2Fknowledgecenter%2Fssw_ibm_i_72%2Frzarg%2Fname_mangling.htm&usg=AOvVaw1JsTeSnCRnH6Cm-FjtqOUq)。

此外，还需要说明一下，虽然静态成员函数和非静态成员函数(统称成员函数)都位于`text segment`中，但是他们之间最重要的区别是非静态成员在调用的时候没有`this`指针传入。

接着，对于`virtual`关键字，编译器会自动在对象的内存布局中插入一个`_vptr`指针指向一张虚表。在虚表中，`type_info`包含当前类的相关信息，如果有基类，那么还有有其他基类的信息（DAG）。

`_vptr`的数据类型在标准中没有提及。

## 继承对象

c++的继承一般分为三种，单一继承，多重继承和虚继承。如下是单一继承：

```c++
class X {
    int     x;
    string str;

public:
    X() {}
    virtual ~X() {}

    virtual void printAll() {}
};

class Y : public X {
    int     y;

public:
    Y() {}
    ~Y() {}

    void printAll() {}
};
```

其内存布局如下：

```
      |                              |          
      |------------------------------| <------ Y class object memory layout
      |          int X::x            |
stack |------------------------------|
  |   |              int string::len |
  |   |string X::str ----------------|
  |   |            char* string::str |         
 \|/  |------------------------------|      |-------|--------------------------|
      |           X::_vptr           |------|       |       type_info Y        |
      |------------------------------|              |--------------------------|
      |          int Y::y            |              |    address of Y::~Y()    |
      |------------------------------|              |--------------------------|
      |               o              |              | address of Y::printAll() |
      |               o              |              |--------------------------|
      |               o              |              
------|------------------------------|--------
      |           X::X()             | 
      |------------------------------|       |   
      |           X::~X()            |       |
      |------------------------------|       | 
      |         X::printAll()        |      \|/ 
      |------------------------------|  text segment
      |           Y::Y()             |
      |------------------------------|
      |           Y::~Y()            |
      |------------------------------|
      |         Y::printAll()        |
      |------------------------------|
      |      string::string()        |
      |------------------------------|
      |      string::~string()       |
      |------------------------------|
      |      string::length()        |
      |------------------------------|
      |               o              |
      |               o              |
      |               o              |
      |                              |
```

在继承模型中，基类和数据成员类都是派生类的一个子对象(如上图的 `X`，`string`)。

注意，此时虚表中所有被`overriden`的虚函数以及其他信息在构造函数阶段会被编译器生成并赋给`_vptr`。

## 多重继承下具有虚函数的对象

`Z`从`X`和`Y`派生而来，同时`X`和`Y`中都有虚函数。代码如下：

```c++
class X {
public:
    int     x;
    
    virtual ~X() {}
    virtual void printX() {}
};

class Y {
public:
    int     y;
    
    virtual ~Y() {}
    virtual void printY() {}
};

class Z : public X, public Y {
public:
    int     z;
    
    ~Z() {}
    void printX() {}
    void printY() {}
    void printZ() {}
};
```
其内存布局如下:

```
      |                              |          
      |------------------------------| <------ Z class object memory layout
stack |          int X::x            |         
  |   |------------------------------|                  |--------------------------|      
  |   |          X:: _vptr           |----------------->|       type_info Z        |
  |   |------------------------------|                  |--------------------------|
 \|/  |          int Y::y            |                  |    address of Z::~Z()    |
      |------------------------------|                  |--------------------------|
      |          Y:: _vptr           |------|           |   address of Z::printX() |
      |------------------------------|      |           |--------------------------|
      |          int Z::z            |      |           |--------GUARD_AREA--------|    
      |------------------------------|      |           |--------------------------|
      |              o               |      |---------->|       type_info Z        |
      |              o               |                  |--------------------------|
      |              o               |                  |    address of Z::~Z()    |
      |                              |                  |--------------------------|
------|------------------------------|---------         |   address of Z::printY() |
      |           X::~X()            |       |          |--------------------------|  
      |------------------------------|       |          
      |          X::printX()         |       |        
      |------------------------------|       |         
      |           Y::~Y()            |      \|/        
      |------------------------------|  text segment
      |          Y::printY()         |                
      |------------------------------|                
      |           Z::~Z()            |                
      |------------------------------|                
      |          Z::printX()         |                
      |------------------------------|                
      |          Z::printY()         |                
      |------------------------------|                
      |          Z::printZ()         |                
      |------------------------------|                
      |               o              |                
      |               o              |                
      |                              |                
```

在多重继承的层次结构中，此时我们有两个`_vptr`分别来自`X`和`Y`。

## 虚继承

```c++
class X { int x; };
class Y : public virtual X { int y; };
class Z : public virtual X { int z; };
class A : public Y, public Z { int a; };
```
其内存布局如下：
```
                  |                |          
 Y class  ------> |----------------| <------ A class object memory layout
sub-object        |   Y::y         |          
                  |----------------|             |------------------| 
                  |   Y::_vptr_Y   |------|      |    offset of X   | // offset(20) starts from Y 
 Z class  ------> |----------------|      |----> |------------------|     
sub-object        |   Z::z         |             |       .....      |     
                  |----------------|             |------------------|  
                  |   Z::_vptr_Z   |------|       
                  |----------------|      |        
 A sub-object --> |   A::a         |      |      |------------------| 
                  |----------------|      |      |    offset of X   | // offset(12) starts from Z
 X class -------> |   X::x         |      |----> |------------------|          
 shared           |----------------|             |       .....      |           
 sub-object       |                |             |------------------|           
```

此是内存布局包含两个区域：

+ 不可变区域
+ 共享区域(`X`变成一个共享对象，也就是其只存在一份)
