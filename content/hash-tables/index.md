+++
title = "cmu15-455 Hash Tables"
date = 2022-08-21

[taxonomies]
tags = ["hash", "database", "cmu15-455"]
[extra]
mathjax = "tex-mml"
+++

本节分析了几种常见的hash函数，重点讲解了hash碰撞后的处理方式，包括静态hashing和动态hashing.

## 数据结构

DBMS使用各种各样的数据结构应用在系统内部的各个部分。

+ 内部元数据(internal meta-data): 追踪有关数据库和系统状态的信息
+ 核心数据存储(core data storage): 数据库中用于元组(tuples)的基本存储
+ 临时数据结构(tmeporary data structures): DBMS在处理查询时动态构建数据结构，加快查询速度(如 哈希表用于joins).
+ 表索引(table indexes): 辅助性数据结构， 便于特定元组更容易找到

设计决策(design decisions):
 1. 数据组织： 如何对内存进行布局以及在数据结构中存储哪些信息。 
 2. 并发： 如何在启用多个线程访问数据结构时不引发并发问题。

## 哈希表
哈希表实现了将键映射到值的关联数组抽象数据类型。

实现由两部分组成：
 + **Hash Functions**: 如何将一个大的key空间映射到一个更小的域中。通常需要考虑到速度和碰撞率之间的权衡。
 + **Hashing Scheme**: 如何处理key映射之后产生的碰撞。 需要在分配一个大的hash table来减少碰撞和执行额外的操作来查找和插入keys之间进行权衡。

## Hash Functions

哈希函数接受一个key作为输入，然后返回一个该key的整数表示的值。函数的输出是确定的(如相同的key总是产生相同的哈希输出)。

DBMS并不使用加密的哈希函数(如 SHA-256)，因为我们不需要考虑对键的内容进行保护。因为这些哈希函数主要作为系统内部使用，不用担心信息泄漏。

当前的`state-of-the-art`哈希函数是`Facebook XXHash3`

集中哈希函数的性能比较
![](./2022-08-21_21-26.png)

## 静态Hashing Scheme

静态哈希方案是一种哈希表大小固定的应用方案。意味着如果DBMS用完了哈希表中的存储空间，那么他需要用一个更大的表从新进行构建。通常新表的大小是原来的两倍。

主要介绍三种方案：

1. `linear probe hashing`
2. `robin hood hashing`
3. `cuckoo hashing`

### Linear Probe Hashing

所有元素都存放在哈希表的数组中，不使用额外的数据结构。

线性探查(linear probe)是开发寻址法的最简单一种实现。步骤如下：

1. 插入新元素时，使用哈希函数在哈希表中定位元素位置。
2. 检查哈希表中该位置是否存在元素，如果为空，插入并返回，否则进行步骤3
3. 如果该位置为`i`, 检查`i+1`是否为空，如果已被占用，则继续检查`i+2`的位置，依次类推，直到找到一个空的位置。

这种方式的缺点是会导致同类哈希的聚类(prmary clustering)。

### Robin Hood Hashing

这是线性探查的一种扩展。寻求减少每个键在哈希表中的最佳位置到它们的最大距离。

记录每个key到其最优插入位置的探查长度。当插入一个新元素时，在探查的过程中，如果插入的元素的探查长度大于当前元素的探查长度时，那么交换这两个元素(以及探查长度)，然后继续探查。

探查长度更加平均，所以期望最长的探查长度也会显著下降。故这也是罗宾汉这个名字的由来，劫富济贫。

### Cuckoo Hashing

与之前使用单个哈希表的方案不同，这种方案使用不同的哈希函数维护多个哈希表。哈希函数是相同的(如 XXHash, CityHash)，它们使用不同的种子值对同一个key对应生成不同的哈希值。

在多个表中查找空闲的位置。因为每个哈希表只检查一个位置，所以查找和删除始终为O(1).

在插入时，检查每个表并选择任何有空闲插槽的表。

如果没有表有空闲插槽，则从其中一个删除该元素，然后重新哈希它寻找新的空闲位置。方式如下：
![](./2022-08-21_22-06.png)
![](./2022-08-21_22-06_1.png)
![](./2022-08-21_22-07.png)
![](./2022-08-21_22-07_1.png)

